[{"id":"7da6aeab0eda93c9561c5efa31f315f6","title":"面试复盘，Java应届生","content":"\n\n\n主要内容\n日期 &#x2F; 地点\n面试结果\n\n\n\nJava基础、并发编程、JVM、MQ、业务设计。\n2022-11-05 线上\n一般\n\n\n业务设计\n\n\n\n\n\n\n\n\n说说业务设计时你会考虑什么\n首先，我会先确认好业务需求，明确这个功能会接受什么样的输入，产生什么样的输出。然后跟上游沟通好是否需要进行额外的特殊处理，比如说异步、幂等性或者高并发。然后根据功能的大小将其为多个明确的子功能。然后以验收测试驱动开发的思想，我会先准备好子功能的测试用例（至少包含正常状态和异常输入状态）。对每个子功能进行详细的思路设计（在大脑中找出实现的方案，然后找出最短的可行路径），编写单元测试。实现代码。\nJava基础\n\n\n\n\n\n\n\n\nequals和&#x3D;&#x3D;的区别\n对于基本类型，&#x3D;&#x3D;判断两个值是否相等，euqals方法不存在于基本类型中；对于引用类型，&#x3D;&#x3D;判断两个引用是否指向同一个对象，equals用于比较两个对象是否等价；Object类中的equals方法默认比较的就是地址。\n\n\n\n\n\n\n\n\n\n为什么说重写equals后要重写hashcode方法\nJava之所以使用了equals和hashCode两个方法来判断两个对象是否相等，是出于可靠性和性能。\n\nequals用于比较两个对象是否绝对相等。\nhashCode用于快速判断两个对象是否相等，由于哈希碰撞可能会出现误差。\n\n我们对于这两个方法会有以下约定：\n\n两个对象的euqals相等，hashCode一定相等。\n两个对象的hashCode相等，euqals方法不一定相等。\n\n如果只重写了equals而没有重写hashCode方法，会导致new出了两个相同属性的对象，其调用equals方法之后是相等的，但是他们hashCode方法继承于Object类，是比较两个对象的内存地址，散列值不同。这就违背了equals的可靠性\n\n\n\n\n\n\n\n\n\nArrayList和LinkedList的区别\nArrayList是基于数组这个数据结构实现的，LinkedList是基于链表实现的。前者在随机访问和尾部操作时的效率高，后者在插入和删除时的效率高，但链表的内存占用比较大。而LinkedList的一个优势是其使用了Deque接口，这就意味着其可以作为栈、队列两个数据结构的具体实现。\n\n\n\n\n\n\n\n\n\n并发场景下如何保证列表的线程安全\nJDK中提供了三种线程安全的列表：Vector、syncronizedList和copyOnWriteList\n\nVector是从JDK1.0开始就提供了线程安全列表，但是其实现方式十分的粗暴。就是通过在对外提供的public的方法上添加上syncronized关键字来实现的，所以性能较低。\nCollections.synchronizedList(List list) 是 JDK1.2 版本后推出的Collections工具类中的API，能够返回指定参数列表的线程安全版本。 其实现方式是通过减少syncronized的同步粒度来优化性能。\ncopyOnWriteList 是从JDK1.5版本后由juc工具包的开发大佬Doug Lea编写的基于写时复制机制实现的线程安全列表。目的在于将列表的读性能发挥极致，在类的使用过程中读和写操作都互不干涉。在写的时候会从原数组中复制出一个新的数组，然后对新数组进行写操作后再将其覆盖回原数组。而此时如果发生了读操作就只能够读取到旧的数组，由于读写操作位于不同的数组上，所以不会发生线程安全问题。\n\n\n\n\n\n\n\n\n\n\nJava的错误机制\nThrowable是Java中所有异常和错误的父类。其中包含了printStackTrace()接口用于获取堆栈信息。\n而Throwable的有两个子类：Error和Exception。Error是程序无法处理的错误，一般是由于运行程序中出现了严重错误。一般表示JVM在运行时出现问题，比如NoClassDefFoundError、OutOfMemoryError和StackOverFlow Error。\nException是程序本身可以捕获并且处理的异常，又分为两个子类：RuntimeException和编译器异常（Java中没有明确的定义类）RuntimeException是程序运行中才会出现的异常，比如说数组下标越界、空指针异常等。这类异常一般是由于程序逻辑错误导致的。\n编译器异常从程序语法角度讲是必须处理的异常，如果不能处理编译就不能通过。 比如IOException、SQLException。所以这类异常也叫做受检异常， 受检异常虽然是异常状态，但是从某种程度上他是可以预知的，所以Java编译器会对其进行检查，如果出现这类异常要么使用try-catch捕获他，要么使用throws声明抛出它，否则将会编译不通过。\n\n\n\n\n\n\n\n\n\nJava包装类的缓存机制\nJDK会为Boolean、Byte、Short、Integer、Character包装类中的值进行缓存，Integer中默认缓存池范围是-128～127。如果在缓存池范围内的包装类对象调用valueOf方法的话就取出缓存池中的值，而不是创建一个新对象了。这样做就能够节约内存并且提高运行效率，因为对象已经创建好了就无需再重复创建。\nJava并发编程\n\n\n\n\n\n\n\n\n并发编程三要素\n原子性、可见行和有序性。\n\n\n\n\n\n\n\n\n\n线程池中的线程出现了异常会发生什么？\n当线程池中的线程出现异常时，会被Executors框架捕捉到，对于Runnable接口的类会被隐藏；对于Callable方法在调用其返回值Future对象的get方法时，Executors会将异常信息传递给调用者。\nJVM\n\n\n\n\n\n\n\n\n泛型的作用是什么？JVM是如何实现泛型特性的？\n泛型的作用是参数化数据类型，在泛型使用过程中，操作的数据类型被指定为一个参数。JDK1.5在版本之后推出的新特性，考虑到向前兼容这个特性，所以使用到的实现方案是擦除法，本质上就是一个语法糖，参数类型会在代码在编译后就被擦除，就像没有泛型一样。\nTODO：其他语言中泛型的解决方案。\n\n\n\n\n\n\n\n\n\n volatile关键字的作用\nvolatile关键字的作用是保持变量的可见性和有序性和原子性。\n\n有序性是指防止操作系统对指令进行重排，比较经典的例子就是单例模式的双重检查，因为实例化对象的步骤可以分为：分配内存空间、初始化对象和内存空间地址赋值给引用。 但是OS会对指令进行重排序，导致实际执行顺序不同，为了防止这个重排序，所以我们需要在使用volatile关键字修饰单例对象。\n可见性问题是指当一个线程修改了共享变量而另外一个线程看不到。 这个问题的主要原因是因为没个线程都拥有自己的高速缓存区 – 线程工作内存。 而volatile关键字能够解决这个问题：当变量发生变化时，会立即刷回主内存中，并及时通知其他线程的缓存更新。\n原子性，volatile关键字能够保证单次读&#x2F;写的原子性。 long和double两种数据类型是64位的，而对于32位的JVM来说，会将其分为高32位和低32位进行缓存。因此普通的long或double类型的读&#x2F;写操作不是原子的。\n（目前各个平台的商用虚拟机包括HotSpot都会将64位数据的读写操作作为原子操作来对待，因此不使用volatile进行修饰也不会出错的）\n\n\n\n\n\n\n\n\n\n\n\n\nJVM内存屏障是什么？ 如何实现？\n\n\n\n\n\n\n\n\n\nJVM如何保证volatile的特性的？\nJVM是通过内存屏障来保证volatile的特性的。内存屏障是一个CPU指令，会告诉编译器和CPU不管什么指令都不能和这条Memory Barrier指令重排序。\n对于可见性：从编译后的代码来看，对于volatile关键字变量的写操作前会添加上lock前缀，这个前缀会发生两件事：将当前处理器的缓存行数据写回系统内存。通知总线该变量被修改了。而其他处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了， 如果过期了就将数据设置为无效状态。通过这样的机制使得每个线程都能够获得该变量的最新值。\n对于有序性：编译器会在生成指令序列时在适当的位置插入内存屏障指令来禁止特定类型的处理器重排序。对于volatile变量\n\n在每一个读操作后插入LoadLoad和LoadStore屏障。 \n在每一个写操作前插入StoreStore屏障，写操作后插入StoreLoad屏障。\n\n\n\n\n\n\n\n\n\n\nJVM如何保证synchronized的同步的？\nsynchronized是Java中进行同步操作最基本的关键字，可以作用在方法和代码块中。对于被syncronized修饰的方法或者代码块，编译器会在前后加上monitorenter和monitorexit两个指令。monitor可以看作是一把锁，每个对象在同一时间只能和一个monitor关联，且每个monitor只能够被一个线程获得。对于monitor的实现和可重入锁类似。monitorenter是否有这个monitor的所有权，如果有则表示重入锁，则计数器加一。若果没有，会检查计数器的次数，如果为0表示这个锁还没有被其他线程获得，则立即获得这把锁，并计数器加+1。对于对于monitorexit指令，就是将monitor计数器减一，如果为0则表示释放锁。\n网络\n\n\n\n\n\n\n\n\n三次握手\n三次握手是TCP的连接建立过程，与HTTP协议无关，只不过因为HTTP协议是基于于TCP实现的应用层协议。握手之前，客户端和服务端都处于CLOSE状态，然后先是服务端主动监听某个端口，处于LISTEN状态。第一次握手时，客户端初始化一个随机序列号放入报文首部的「序列号」字段中，然后将报文的SYN标志位设置为1，发送给服务端，随后客户端进入SYN_SENT状态。第二次握手时，服务端接收到客户端的SYN报文后，初始化自己的序列号，填入「序列号」字段，然后将「确认答应」字段填入客户端的seq+1，然后把SYN和ACK标志位设置为1，发送给客户端。服务端进入SYN_RCVD状态。第三次握手时，客户端收到服务端的报文后，最后回复一个答应报文，将ACK标志位设置为1，然后将服务端报文中的seq+1填入TCP报文首部的「确认答应」字段中，发送给客户端，进入ESTABLISH状态。服务端收到后也会进入ESTABLISH状态。\n\n\n\n\n\n\n\n\n\n三次握手能够附带数据吗？\n由于第三次握手时能够确认客户端和服务端能够建立连接，所以处于性能考虑，第三次握手时的报文是可以附带数据的。 而前两次握手的主要目的在于「建立连接」所以不能携带报文。\n\n\n\n\n\n\n\n\n\n为什么要三次握手？ 两次不行吗\n因为要考虑到网络阻塞的问题，当第一次握手时，客户端发送的\n\n\n\n\n\n\n\n\n\n什么是跨域问题？\n跨域问题是源于浏览器的同源策略。 这是浏览器中一个重要的安全策略，防止XSS、CSFR等浏览器层面的攻击。而同源是指：相同的协议、相同的域名和相同的端口所以当访问不同协议、不同域名、不同端口的资源时会出现跨域问题。\n当我们的项目是前后端分离架构时，前后端可能会部署在不同的服务器上，这时就会导致跨域的问题。\n\n\n\n\n\n\n\n\n\n解决跨域问题的常见方案？\n\nNginx方向代理。使用Nginx作为一层跳板机，将指定同源域名后的资源（比如说&#x2F;api）映射到具体后端服务器地址，实现跨域功能。\n\nhttp &#123;\n  server &#123;\n    location ~/api &#123;\n      # 反向代理\n      proxy_pass xxxxx; #\n    &#125;\n\n\nWebpack Server代理，可以在webpack.config.js中配置一个devServer，然后将指定资源映射到具体后端服务器的地址。\n\nmodule.exports = &#123; \n  devServer: &#123; \n    port: 3000, \n    proxy: &#123; \n      \"/api\": &#123; \n        target: \"http://localhost:3001\" \n      &#125; \n    &#125; \n  &#125;, \n&#125;;\n\n\n\n\n\n\n\n\n\n\n我们使用到的IDE：Webstorm、IDEA等是如何直接运行vue项目的？\nIntelliJ公司的IDE会内置一个轻量级的NodeJs的服务器，当我们在Configurations中配置好前端项目的package.json后会自动将前端项目编译打包放入node服务器进行运行。\nMQ\n\n\n\n\n\n\n\n\n线程池同样能够做到异步的作用，那么为什么还要使用MQ？\n第一个核心作用是削峰，比如当上游处理简单请求，平均处理速度为1w&#x2F;s，而下游处理秒杀的复杂请求，平均处理速度为2k&#x2F;s。 为了防止下游系统不被压垮，我们就需要引入MQ的削峰功能。我们就可以通过MQ的MQ-clinet模式，将下游的处理方式从MQ推送变为Client拉取。 这样下游就能够根据自己的处理能力，每隔一段时间拉取若干信息。\n第二个核心功能是解藕，这个解藕不单单是指生产者和消费者的解藕。 当上下游服务系统是异构的话，就需要MQ来帮助我们实现通讯的功能。\n参考文章：\n《图解HTTP》 作者：小林Coding\nJava全栈知识体系：https://pdai.tech/md/java/basic/java-basic-lan-basic.html\n\n","slug":"面试复盘，Java应届生","date":"2022-11-07T03:07:40.000Z","categories_index":"","tags_index":"","author_index":"Aurora"}]