{"title":"Java中属性初始化的差异","uid":"4b2a67d332f9fb2b23f7506e99d7e81b","slug":"Java中属性初始化的差异","date":"2023-05-05T13:14:39.000Z","updated":"2023-05-05T13:16:35.902Z","comments":true,"path":"api/articles/Java中属性初始化的差异.json","cover":null,"content":"<p>在Java中，你可以直接在声明属性时初始化、也可以在构造函数中初始化、甚至可以在static代码块中初始化，那么三者有什么差异呢？</p>\n<ol>\n<li><p>初始化的时机不同<br>static代码块中的代码会在类第一次加载时就进行，不需要实例的存在。<br>而构造函数和属性中初始化的变量在对象创建时才进行。<br>所以static代码块适用于被static关键字修饰的属性初始化。</p>\n</li>\n<li><p>错误的处理<br>如果在属性中初始化时发生错误很难处理异常。<br>但是在static和构造函数中可以通过try-catch的语句来捕获并处理异常，适用于更复杂的场景。</p>\n</li>\n</ol>\n<p>所以如果变量需要在多个对象之间共享，或者需要在对象不存在时就进行初始化，应该使用static代码块进行初始化。</p>\n","text":"在Java中，你可以直接在声明属性时初始化、也可以在构造函数中初始化、甚至可以在static代码块中初始化，那么三者有什么差异呢？ 初始化的时机不同static代码块中的代码会在类第一次加载时就进行，不需要实例的存在。而构造函数和属性中初始化的变量在对象创建时才进行。所以stat...","link":"","photos":[],"count_time":{"symbolsCount":305,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"}],"toc":"","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"注册JVM钩子函数来实现优雅停机","uid":"7d219fe8f2483d731e9b880a374df88c","slug":"java/注册JVM钩子函数来实现优雅停机","date":"2023-05-08T05:37:12.125Z","updated":"2023-05-09T08:33:16.966Z","comments":true,"path":"api/articles/java/注册JVM钩子函数来实现优雅停机.json","cover":null,"text":"在各种连接池场景下，当应用发生了关闭。那么所有连接池（数据源、请求业务线程）都会强行的中止线程，如果此时正在发生一些较为重要的业务操作也会被强制停止。 因此作为有经验的工程师，我们会通过Runtime::addShutdownHook()来帮助我们注册JVM的关闭钩子，已达到JV...","link":"","photos":[],"count_time":{"symbolsCount":746,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Volatile关键字小结","uid":"752d53d9b20a96f3018bcb72f69595d6","slug":"Volatile关键字","date":"2023-05-05T13:13:39.000Z","updated":"2023-08-08T09:15:24.310Z","comments":true,"path":"api/articles/Volatile关键字.json","cover":null,"text":"Voaltile关键字用于保证变量在多线程环境下的可见性、禁止指令重排。 为什么多线程环境下会出现这些问题？主要是由于JMM的存在。 可见性：而多线程环境下如果一个线程修改了变量，那么其他线程保存中的副如果没有同步的从主内存中读取，就造成了可见性的问题。 指令重排：指令重排技术是...","link":"","photos":[],"count_time":{"symbolsCount":454,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"多线程","slug":"多线程","count":1,"path":"api/tags/多线程.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}