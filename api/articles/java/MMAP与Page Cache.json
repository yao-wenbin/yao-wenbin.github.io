{"title":"MMAP/Page Cache - 以Javaer的角度看待内存映射文件机制","uid":"90732c789d41e9ff8627e26b080796f4","slug":"java/MMAP与Page Cache","date":"2023-05-09T08:20:21.340Z","updated":"2023-05-09T08:33:56.261Z","comments":true,"path":"api/articles/java/MMAP与Page Cache.json","cover":null,"content":"<h2 id=\"什么是MMAP？\"><a href=\"#什么是MMAP？\" class=\"headerlink\" title=\"什么是MMAP？\"></a>什么是MMAP？</h2><p>MMAP(Memory-mapped file)是一种内存映射文件的机制。用于建立从文件到内存之间的一种映射，将对磁盘的写入映射为对内存的写入，以增加对于文件IO的效率。</p>\n<p>在Linux上主要通过mmap()、munmap()、msync()等系统调用来实现。</p>\n<h2 id=\"什么是Page-Cache？\"><a href=\"#什么是Page-Cache？\" class=\"headerlink\" title=\"什么是Page Cache？\"></a>什么是Page Cache？</h2><p>Page Cache页缓存是Linux实现MMAP机制的底层关键组件，其将文件分为多个大小为4KB的数据块。</p>\n<p>前面说文件传输过程中，将磁盘文件拷贝到内核缓冲区中，这个缓存区实际上就是Page Cache。</p>\n<p>PageCache的大小在32位OS中为4K，在64位操作系统中大小为8K。<br>PageCache有两个特性：</p>\n<ol>\n<li><p>缓存<br>在操作系统中，具有「局部性」，即刚被访问的数据再次被访问的概率更高。 所以Linux中使用Page Cache来缓存最近被访问的数据。所以读取磁盘的时候会有先从Page Cache中读取，如果没有再从磁盘中读取。</p>\n</li>\n<li><p>预读<br>PageCache的一个很好的特性就是预读，也就是当应用程序发生读操作时，文件系统会提前为应用程序读取的文件加载更多的数据到Page Cache中，这样下一次读取的时候就可以直接命中Page Cache了。（很多地方都运用到了这样的技术，比如说JVM中）<br>有效的减少了磁盘的访问次数。</p>\n</li>\n</ol>\n<p>在Java NIO中通过Channel.map()方法即可将文件区域映射到内存中实现MMAP机制，其会返回一个MappedByteBuffer对象。这个对象在Linux映射的内存区域实际上就是Page Cache。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">FileChannel</span> fileChannel <span class=\"token operator\">=</span>  <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomAccessFile</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/tmpFile\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"rw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getChannel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n\n<span class=\"token class-name\">MappedByteBuffer</span> mappedByteBuffer <span class=\"token operator\">=</span> fileChannel<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">FileChannel<span class=\"token punctuation\">.</span>MapMode</span><span class=\"token punctuation\">.</span><span class=\"token constant\">READ_WRITE</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"零拷贝的限制\"><a href=\"#零拷贝的限制\" class=\"headerlink\" title=\"零拷贝的限制\"></a>零拷贝的限制</h2><ol>\n<li>不适合大文件，因为MMAP在加载的时候是预先加载内存中的空间的，如果映射文件太大就会造成占用过的内存空间。</li>\n<li>不适合变长文件，因为MMAP在使用的时候需要指定映射文件的大小，一般为内存页的整数倍。</li>\n<li>磁盘延迟，MMAP是通过缺页中断向磁盘发起真正的IO请求，而具体是何时写入将交由系统来决定，而不是应用程序。</li>\n</ol>\n<h2 id=\"RocketMQ中对零拷贝的优化\"><a href=\"#RocketMQ中对零拷贝的优化\" class=\"headerlink\" title=\"RocketMQ中对零拷贝的优化\"></a>RocketMQ中对零拷贝的优化</h2><ol>\n<li>内存预映射机制<br>RocketMQ通过维护一个MappedFileQueue队列，在每次消息的写入都获取消息队列中的最后一个MappedFile，<strong>如果没有则会创建一个并且将下一个也创建好</strong>。</li>\n<li>文件预热<br>在调用mmap()进行内存映射时，其实只是建立起虚拟内存与物理地址的映射关系，不会加载任何文件到内存中。<br>而RocketMQ的在MappedFile#warmMappedFile方法中，每隔一个页(4k)就put一个0，将文件加载到内存中，这样当消息读取或者写入的时候可以直接命中Page Cache。</li>\n<li>mlock内存锁定<br>在warmMappedFile()预热后还会调用mlock方法， 将预热后的内存空间进行锁定，来防止操作系统将内存空间调到swap空间中。</li>\n</ol>\n","text":"什么是MMAP？MMAP(Memory-mapped file)是一种内存映射文件的机制。用于建立从文件到内存之间的一种映射，将对磁盘的写入映射为对内存的写入，以增加对于文件IO的效率。 在Linux上主要通过mmap()、munmap()、msync()等系统调用来实现。 什么...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"OS","slug":"OS","count":1,"path":"api/tags/OS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFMMAP%EF%BC%9F\"><span class=\"toc-text\">什么是MMAP？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFPage-Cache%EF%BC%9F\"><span class=\"toc-text\">什么是Page Cache？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E9%99%90%E5%88%B6\"><span class=\"toc-text\">零拷贝的限制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RocketMQ%E4%B8%AD%E5%AF%B9%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">RocketMQ中对零拷贝的优化</span></a></li></ol>","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"你真的了解你的MySQL吗(MySQL基准测试)","uid":"4468f948c4ca4e742d657728958a113e","slug":"你真的了解你的MySQL吗-MySQL基准测试","date":"2022-11-12T13:31:33.000Z","updated":"2022-11-12T13:31:47.878Z","comments":true,"path":"api/articles/你真的了解你的MySQL吗-MySQL基准测试.json","cover":[],"text":"如果你没有真正的对服务器上的MySQL进行基准测试，就无法了解其真实情况到底是如何。 基准测试是数据库工程师必备的技能之一，否则你如何知道自己真的在优化数据库？ 为什么需要基测？基测可以观察系统在不同压力下的行为： 验证基于系统的一些假设是否符合实际情况。 测试当前的运行情况，如...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":5,"path":"api/tags/MySQL.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"注册JVM钩子函数来实现优雅停机","uid":"7d219fe8f2483d731e9b880a374df88c","slug":"java/注册JVM钩子函数来实现优雅停机","date":"2023-05-08T05:37:12.125Z","updated":"2023-05-09T08:33:16.966Z","comments":true,"path":"api/articles/java/注册JVM钩子函数来实现优雅停机.json","cover":null,"text":"在各种连接池场景下，当应用发生了关闭。那么所有连接池（数据源、请求业务线程）都会强行的中止线程，如果此时正在发生一些较为重要的业务操作也会被强制停止。 因此作为有经验的工程师，我们会通过Runtime::addShutdownHook()来帮助我们注册JVM的关闭钩子，已达到JV...","link":"","photos":[],"count_time":{"symbolsCount":746,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}