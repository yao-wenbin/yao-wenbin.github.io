{"title":"Kafka架构与核心概念","uid":"b616fd44c5f7ef9bc2632badbc783987","slug":"Kafka架构与核心概念","date":"2023-08-08T08:57:39.000Z","updated":"2023-08-08T09:15:12.609Z","comments":true,"path":"api/articles/Kafka架构与核心概念.json","cover":null,"content":"<p>![](Pasted image 20230808161829.png)</p>\n<p>Kafka Cluster集群：Kafka集群会由一个或多个Broker（有的地方也叫server或者是node）组成，Broker负责Producer和Consumer之间的消息传递和持久化。 是整个架构中Kafka的核心服务。</p>\n<p>Zookeeper Node：Kafka集群需要ZK来保证节点之间的通信，并且使用Zookeeper来存储每个Broker下的核心信息，包括Broker地址，Topic主题的信息，Broker所负责的Topic下的Partition分区。</p>\n<p>Topic：是一系列相关主题的合集，Kafka中每个消息都会有有且仅有一个主题，不同的消息通过主题从逻辑上区分。</p>\n<p>Partition分区：是Topic的实际存储区域，一个Topic下会有多个Partition，分布在Kafka Cluster中的不同节点上，使得一个主题能够具有更大的吞吐量。Partition是Kafka能够具有横向扩展能力的核心，通过不断的增加Broker，Partition从理论上也能够无限衍生。使得吞吐量也能够无限增长。<br>Kafka Cluster能够保证Partition会尽可能均衡的存放于每一个Broker中。</p>\n<p>Producer生产者：是消息的创建方，能够显示的或者隐式的将消息发送往主题下的某一个具体的分区中。</p>\n<p>Consumer消费者：是消息的使用方，在创建时能够指定订阅的主题。 连接上Broker后，Broker会根据当前主题和Consumer之间的关系，为其分配一个或多个Partition。 分配完成后，Consumer开始根据Consumer Offset消费进度进行消费。</p>\n<p>Consumer Group消费者组：标明一组相同业务逻辑的Consumer，使得消费者也能够横向扩展。当出现消息积压的时候，能够通过不断的增加消费者实例来快速消费消息。</p>\n<p>Consumer Offset消费进度：当消费者消费完一条消息时，会提交自身当前对于已消费记录的消费进度，使得消费者宕机或者断开连接时，其他消费者能够根据分区当前的消费进度继续消费该分区的消息。</p>\n<p>Offset Commit Point消息提交点：Kafka的Consumer在消费完消息之后的提交位置，通过变更消息，使得kafka的交付策略能够在at-most-once、at-least-once、exactly-once三重语义中切换。</p>\n<p>Record记录&#x2F;Message消息：数据存储的最小单元，也是一个具体发生事件的承载体。</p>\n<p>Key消息键：每个消息都能够标记一个非唯一的任意类型的数据，在Kafka Producer的消息发送策略中，如果没有显示的指定分区号，则会通过Key进行Hash，然后和分区数量求余，取得一个分区号使得具有相同Key的消息总是会分布在同一个分区中。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里存在着一个问题，因为Hash的算法还存在一个变量就是分区数量，所以当Kafka中的分区通过Kafka管理工具进行修改之后，具有相同Key的新新消息可能不再和旧消息存放于同一个分区中。 这在需要保证消息顺序的场景下需要注意的地方。</p></blockquote>\n<p>Partially Order部分顺序：Kafka中一个Partition分区下的消息是天然有序（Total Order）的，而由Partition分区组成的Topic主题是部分有序的（Partially Order）</p>\n","feature":true,"text":"![](Pasted image 20230808161829.png) Kafka Cluster集群：Kafka集群会由一个或多个Broker（有的地方也叫server或者是node）组成，Broker负责Producer和Consumer之间的消息传递和持久化。 是整个架构...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":1,"path":"api/tags/MQ.json"}],"toc":"","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Performance Schema入门指南:你的MySQL性能监测杀器","uid":"ba1c6774f6090755efbcf2d6c3343eae","slug":"Performance-Schema入门指南-你的MySQL性能监测杀器","date":"2022-11-28T14:23:44.000Z","updated":"2022-11-28T14:25:33.753Z","comments":true,"path":"api/articles/Performance-Schema入门指南-你的MySQL性能监测杀器.json","cover":null,"text":"简介Performance提供了有关MySQL服务器内部运行的底层指标。在高负载下数据库调优是一个循环迭代的过程，每次更改以调整数据库的性能时，都需要了解更改是否有什么影响。而Performance Schama就是一个能够存储回答这个问题所需要的数据的数据库。 工作机制插桩（i...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":5,"path":"api/tags/MySQL.json"},{"name":"监控","slug":"监控","count":1,"path":"api/tags/监控.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}