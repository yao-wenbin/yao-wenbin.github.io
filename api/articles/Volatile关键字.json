{"title":"Volatile关键字小结","uid":"752d53d9b20a96f3018bcb72f69595d6","slug":"Volatile关键字","date":"2023-05-05T13:13:39.000Z","updated":"2023-08-08T09:15:24.310Z","comments":true,"path":"api/articles/Volatile关键字.json","cover":null,"content":"<p>Voaltile关键字用于保证变量在多线程环境下的可见性、禁止指令重排。</p>\n<p>为什么多线程环境下会出现这些问题？<br>主要是由于JMM的存在。</p>\n<p>可见性：而多线程环境下如果一个线程修改了变量，那么其他线程保存中的副如果没有同步的从主内存中读取，就造成了可见性的问题。</p>\n<p>指令重排：指令重排技术是编译器和处理器对于程序的优化，通过改变某些代码的执行顺序从而提高执行效率，但是也可能因此破坏程序的正确性。</p>\n<p>Volatile的底层原理实际上就是在JVM中每个volatile修饰的变量赋值后增加一个JMM定义的lock操作，来保证每次对变量的读取都是从主内存中读取的。以保证可见性。<br>虽然能够保证可见性，但是volatile不能够确保对变量的写操作能够立刻反应到其他线程中功能，</p>\n<p>适用于：</p>\n<ol>\n<li>状态标记，比如停止线程和停止任务等操作，当一个线程修改了volatile变量的值时，其他线程能够立即看到这个变化。</li>\n<li>双重检查锁定，实现延迟加载和单例模式时，都可以通过volatile实现双重检查锁定，确保变量的可见性以及禁止指令重排。</li>\n</ol>\n","text":"Voaltile关键字用于保证变量在多线程环境下的可见性、禁止指令重排。 为什么多线程环境下会出现这些问题？主要是由于JMM的存在。 可见性：而多线程环境下如果一个线程修改了变量，那么其他线程保存中的副如果没有同步的从主内存中读取，就造成了可见性的问题。 指令重排：指令重排技术是...","link":"","photos":[],"count_time":{"symbolsCount":454,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"多线程","slug":"多线程","count":1,"path":"api/tags/多线程.json"}],"toc":"","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java中属性初始化的差异","uid":"4b2a67d332f9fb2b23f7506e99d7e81b","slug":"Java中属性初始化的差异","date":"2023-05-05T13:14:39.000Z","updated":"2023-05-05T13:16:35.902Z","comments":true,"path":"api/articles/Java中属性初始化的差异.json","cover":null,"text":"在Java中，你可以直接在声明属性时初始化、也可以在构造函数中初始化、甚至可以在static代码块中初始化，那么三者有什么差异呢？ 初始化的时机不同static代码块中的代码会在类第一次加载时就进行，不需要实例的存在。而构造函数和属性中初始化的变量在对象创建时才进行。所以stat...","link":"","photos":[],"count_time":{"symbolsCount":305,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"RocketMQ事务消息","uid":"ad2c272cfe3adee335f5f82ded13d5f6","slug":"rocketmq/事务消息","date":"2023-04-24T06:08:43.782Z","updated":"2023-05-05T13:18:31.519Z","comments":true,"path":"api/articles/rocketmq/事务消息.json","cover":null,"text":"什么是事务首先我们先回顾一下事务的主要作用，是要保证多个操作的原子性，多个事务操作要么一起成功，要么一起失败。 分布式事务使用场景使用场景模拟：用户支付订单后，同时涉及到多个下游：物流发货、积分变更、购物车状态清空。在这个场景中的事务操作有四种： 订单系统的状态状态更新。 物流系...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"RocketMQ","slug":"RocketMQ","count":1,"path":"api/tags/RocketMQ.json"},{"name":"分布式事务","slug":"分布式事务","count":1,"path":"api/tags/分布式事务.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}