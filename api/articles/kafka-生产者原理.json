{"title":"kafka-生产者原理","uid":"2c4486aa05507c9fe7bc6767ce95c998","slug":"kafka-生产者原理","date":"2023-08-17T10:26:08.000Z","updated":"2023-08-17T10:28:18.312Z","comments":true,"path":"api/articles/kafka-生产者原理.json","cover":[],"content":"<h1 id=\"kafka生产者\"><a href=\"#kafka生产者\" class=\"headerlink\" title=\"kafka生产者\"></a>kafka生产者</h1><h2 id=\"生产者架构\"><a href=\"#生产者架构\" class=\"headerlink\" title=\"生产者架构\"></a>生产者架构</h2><p><img src=\"/post/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%9F%E7%90%86/Pasted%20image%2020230817171443.png\"></p>\n<p>一个kafka的生产者将包含着</p>\n<ul>\n<li>MetaData（关于主题、分区的元数据缓存，会定时的从Broker中拉取）</li>\n<li>Partiioner分区器（用于根据消息的Key来决定其所在分区）</li>\n<li>Serializer序列化器（将从Java的POJO对象通过变为一串用于网络传输的数据）</li>\n<li>Interceptors拦截器（由用户对消息进行前置拦截）</li>\n<li>RecordAccumulator（消息累加器，内部是按照分区分配的一个又一个的队列）</li>\n<li>Sender（将消息累加器的消息，通过NetworkClient发送至Broker）。<br>六个核心组件。</li>\n</ul>\n<h2 id=\"kafka是如何管理元数据的？\"><a href=\"#kafka是如何管理元数据的？\" class=\"headerlink\" title=\"kafka是如何管理元数据的？\"></a>kafka是如何管理元数据的？</h2><p>每当kafka的生产者启动、或者是发送消息时拉取到空的MetaData元数据标识，那么就会触发kafka的Sender线程，通过NetworkClient更新MetaData。</p>\n<p><img src=\"/post/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%9F%E7%90%86/Pasted%20image%2020230817174239.png\"></p>\n<h2 id=\"生产者如何实现发送\"><a href=\"#生产者如何实现发送\" class=\"headerlink\" title=\"生产者如何实现发送\"></a>生产者如何实现发送</h2><p>kafka生产者中的send()是通过异步的方式执行的：</p>\n<ol>\n<li>执行producer启动时加载的interceptors拦截器</li>\n<li>执行Serializer序列化器对消息将进行序列化。</li>\n<li>通过Partioner分区器拉取MetaData元数据，并且选择分区。</li>\n<li>将消息放入RecordAccumulator消息累加器对应分区号的队列中。</li>\n<li>等到队列中的消息达到了发送阈值，那么唤醒Sender线程。</li>\n<li>Sender线程创建Reqeust请求。 通过NetworkClient发送给Kafka集群。</li>\n</ol>\n<p>为了提高的提升数据传输的效率，kafka能够使用批处理将多条数据放在同一个请求中发送往broker。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>批处理在数据量很小的情况下能够很大程度的提升性能，因为能够将单次批量的网络传输的开销分摊到多条消息上。<br>但是批处理不适用于单条消息数据量大的情况，否则会因为每次请求的数据量太大，影响处理的效率，进而阻塞网络。</p></blockquote>\n<p>这里的消息发送阈值取自于两个影响kafka生产者批处理行为的参数：<br><code>batch.size</code>：批次大小，当kafka缓冲池下的单个分区队列达到该大小之后，会触发消息发送。（默认为16KB）<br><code>linger.ms</code>：停留时间，当kafka队列中的消息停留多久之后会触发消息发送。（默认为0ms，也就意味着kafka每次都会在一条消息写入缓冲区分区队列后立即发送）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>sender线程在发送网络请求的时候，会因为网络I&#x2F;O产生一定的时间开销。 所以即使linger.ms 为0，在同一时间内多次调用生产者的send()API，kafka依然有可能批量的进行消息发送。</p></blockquote>\n<p><img src=\"/post/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%9F%E7%90%86/Pasted%20image%2020230817174558.png\"></p>\n<h2 id=\"生产者核心：内存池与缓冲队列设计RecordAccumulator\"><a href=\"#生产者核心：内存池与缓冲队列设计RecordAccumulator\" class=\"headerlink\" title=\"生产者核心：内存池与缓冲队列设计RecordAccumulator\"></a>生产者核心：内存池与缓冲队列设计RecordAccumulator</h2><p>kafka的RecordAccumulator是生产者的核心组件，其中使用到了内存池和缓冲队列两个概念来避免大量消息占据大量的堆内存，频繁的引起FullGC问题。</p>\n<p>RecordAccmuluator中有两块区域<br>一个是Batches队列，对于每一个主题的分区下都会有一个队列用于存放当前分区的批次消息。<br>另外一个就是BufferPool内存池了。<br><img src=\"/post/kafka-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%9F%E7%90%86/Pasted%20image%2020230817175603.png\"></p>\n<h2 id=\"生产者如何实现批处理的？\"><a href=\"#生产者如何实现批处理的？\" class=\"headerlink\" title=\"生产者如何实现批处理的？\"></a>生产者如何实现批处理的？</h2><p>在kafka中有两个关键的参数控制者生产者的批处理能力，分别为batch.size（16384，16KB）控制着每次发送批次的大小限制，而linger.ms（0ms）。控制着每个批次的等待时间。</p>\n<p>每一条消息在调用了Producer的发送API之后，都会进入一个Buffer缓冲区中，而kafka通过一个后台I&#x2F;O线程对Buffer缓冲区的消息进行处理。 当Buffer缓冲区的消息到达了linger.ms的时间或者是batch.size的大小后，一批消息就会发送往broker了。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>即使linger.ms被设置了为0，由于异步传输的特性，kafka依然有可能对于一些消息进行批处理。因为每个send()方法都会先序列化记录、分配分区号、然后才将其放入缓冲区中。</p></blockquote>\n<h2 id=\"生产者压缩\"><a href=\"#生产者压缩\" class=\"headerlink\" title=\"生产者压缩\"></a>生产者压缩</h2><p>如果说批处理仅适用于数据体量较小的应用的话，那么消息压缩就适用于所有的场景了。 kafka作为I&#x2F;O密集型的应用，对于CPU的负载率较小， 而压缩恰好是能够使用CPU来换取I&#x2F;O性能。</p>\n<p>所以使用压缩能够很大程度的提升kafka的整体性能。</p>\n<h2 id=\"为什么不管压缩还是批处理，kafka都要选择producer进行实现？\"><a href=\"#为什么不管压缩还是批处理，kafka都要选择producer进行实现？\" class=\"headerlink\" title=\"为什么不管压缩还是批处理，kafka都要选择producer进行实现？\"></a>为什么不管压缩还是批处理，kafka都要选择producer进行实现？</h2><p>因为生产者是消息出生之后第一个接触到的组件，消息从producer开始就进行压缩，就能够保证从producer到broker再到consumer都能够享受到压缩所带来的性能提升。。</p>\n<p>客户端的 <code>compression.type</code>参数控制着压缩的算法，默认情况下为<code>none</code>也就是不压缩。而kafka目前支持gzip、snappy、lz4和zstd四种压缩算法。</p>\n<h2 id=\"如何决定采用哪种压缩算法？\"><a href=\"#如何决定采用哪种压缩算法？\" class=\"headerlink\" title=\"如何决定采用哪种压缩算法？\"></a>如何决定采用哪种压缩算法？</h2><p>如果你的CPU较为敏感，但是依然想要通过压缩来提升性能时，那么LZ4算法能够以较低的CPU开销来实现压缩，但相应的压缩率也会有所下降。</p>\n<p>而当你的网络开始成为瓶颈时，那么使用gzip（2.1.0之前）和zstd（2.1.0及之后）将会带来更大的压缩率，使得压缩的性能进一步提升。</p>\n<h2 id=\"Producer的参数调优\"><a href=\"#Producer的参数调优\" class=\"headerlink\" title=\"Producer的参数调优\"></a>Producer的参数调优</h2><p><code>acks</code>：对于生产者来说是非常重要的参数，决定了kafka写入性能与消息高可用之间的权衡。对于十分重要的业务，通过<code>-1</code>或者是<code>all</code>设定为写入分区的所有ISR副本才响应成功。对于持久化要求不高、但是对于性能的要求却很高的场景可以将其设置为0，也就是当生产者将消息发送给Broker之后立即响应。</p>\n<p><code>max.reqeust.size</code>：生产者能够发送消息的最大大小，默认为1M。对于一些非常多字段的业务对象来说，1M可能会不够用。所以可以根据业务类型适当的调大。</p>\n<p><code>reqeuest.timeout.ms</code>：生产者等待Broker端最大的响应时间，默认值为30000(30s)，当请求超时之后，生产者就会根据retries和retry.backoff.ms进行重试。 </p>\n<p><code>batch.size</code>：缓冲区中每个批次大小，默认为16KB，也就是当分区队列下的消息达到16KB之后就发送。</p>\n<p><code>linger.ms</code>：停留时间，当kafka队列中的消息停留多久之后会触发消息发送。（默认为0ms，也就意味着kafka每次都会在一条消息写入缓冲区分区队列后立即发送）。</p>\n<p>两个批处理的参数是或的逻辑关系处理的，在数据体量较小的情况下建议开启批处理，以提升性能。 但是在消息数据体量较大的情况下，反而要关闭批处理，否则由于数据包太大处理时间太长，造成网络阻塞。</p>\n<p><code>retries</code>：重试次数，默认为0。 这个参数对于at-least-once的语义很重要。kafka在发生了网络都懂、Leader重选等场景下会导致消息的发送失败，根据消息的价值，将其设置为3或者是999是一个理想的选择。</p>\n<p><code>retry.backoff.ms</code>：每次重试间隔，默认100。根据经典局部性原理，当一个消息发送失败了，那么下次还可能发送失败，所以适当的设置间隔可以避免无效的消息重试</p>\n<p><code>compression.type</code>：压缩算法，默认为none，即不压缩。 处于综合吞吐量的考虑，可以设置为<code>lz4</code>算法进行压缩，如果追求高压缩比，则选择<code>zstd</code></p>\n<p><code>buffer.memory</code>：生产者在其JVM中可以使用的缓冲区大小，默认为32M。 可以适当的调大。</p>\n<p><code>max.in.fight.reqeust.per.connection</code> ：单个分区下每次能够同时发起多少个请求，默认值为5。 将其设置为1可以有效的避免同一分区下的消息乱序问题。</p>\n","text":"kafka生产者生产者架构 一个kafka的生产者将包含着 MetaData（关于主题、分区的元数据缓存，会定时的从Broker中拉取） Partiioner分区器（用于根据消息的Key来决定其所在分区） Serializer序列化器（将从Java的POJO对象通过变为一串用于网...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"kafka","slug":"kafka","count":1,"path":"api/tags/kafka.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#kafka%E7%94%9F%E4%BA%A7%E8%80%85\"><span class=\"toc-text\">kafka生产者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">生产者架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#kafka%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">kafka是如何管理元数据的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81\"><span class=\"toc-text\">生产者如何实现发送</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E6%A0%B8%E5%BF%83%EF%BC%9A%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%8E%E7%BC%93%E5%86%B2%E9%98%9F%E5%88%97%E8%AE%BE%E8%AE%A1RecordAccumulator\"><span class=\"toc-text\">生产者核心：内存池与缓冲队列设计RecordAccumulator</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">生产者如何实现批处理的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9\"><span class=\"toc-text\">生产者压缩</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AE%A1%E5%8E%8B%E7%BC%A9%E8%BF%98%E6%98%AF%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%8Ckafka%E9%83%BD%E8%A6%81%E9%80%89%E6%8B%A9producer%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0%EF%BC%9F\"><span class=\"toc-text\">为什么不管压缩还是批处理，kafka都要选择producer进行实现？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">如何决定采用哪种压缩算法？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Producer%E7%9A%84%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">Producer的参数调优</span></a></li></ol></li></ol>","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"你真的了解你的MySQL吗(MySQL基准测试)","uid":"4468f948c4ca4e742d657728958a113e","slug":"你真的了解你的MySQL吗-MySQL基准测试","date":"2022-11-12T13:31:33.000Z","updated":"2022-11-12T13:31:47.878Z","comments":true,"path":"api/articles/你真的了解你的MySQL吗-MySQL基准测试.json","cover":[],"text":"如果你没有真正的对服务器上的MySQL进行基准测试，就无法了解其真实情况到底是如何。 基准测试是数据库工程师必备的技能之一，否则你如何知道自己真的在优化数据库？ 为什么需要基测？基测可以观察系统在不同压力下的行为： 验证基于系统的一些假设是否符合实际情况。 测试当前的运行情况，如...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":5,"path":"api/tags/MySQL.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"RocketMQ-延时队列","uid":"20c628775f69ad677f830c91dd71d5bc","slug":"RocketMQ-延时队列","date":"2023-08-16T00:21:58.000Z","updated":"2023-08-16T00:22:13.857Z","comments":true,"path":"api/articles/RocketMQ-延时队列.json","cover":null,"text":"RocketMQ如何自定义延时级别？RocketMQ在4.3版本之后，MessageStoreConfig配置类中添加了一个十分有用的属性messageDelayLevel。 private String messageDelayLevel = \"1s 5s 10s 30s 1m...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":5,"path":"api/tags/MQ.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}