{"title":"Maven版本管理：使用单个属性来管理项目所有模块的版本号","uid":"3e10980a1e0900db8865138486accab8","slug":"maven/Maven版本管理：使用单个属性来管理项目所有模块的版本号","date":"2023-05-18T13:26:54.141Z","updated":"2023-05-18T13:51:08.102Z","comments":true,"path":"api/articles/maven/Maven版本管理：使用单个属性来管理项目所有模块的版本号.json","cover":null,"content":"<p>本章节将讲解如何使用单个变量来集中一个由Maven组成的多模块项目的版本号</p>\n<p>在开发过程中，我们总是要对项目进行不断的迭代升级，而在Maven的版本控制中，我们可以通过不同的版本号，来将不同版本的项目打包放于同样的地方。<br>![](Pasted image 20230518212916.png)</p>\n<p>默认情况下，我们是这样通过固定的值来管理版本号的：<br>![](Pasted image 20230518212944.png)</p>\n<p>单个项目下维护不存在什么困难，但是如果存在着多个子项目，那么每个子项目中都会有固定的父项目的版本引用，一旦改动，就需要改动所有的pom.xml。</p>\n<p>![](Pasted image 20230518213146.png)</p>\n<p>也许你可以通过全局替换来升级版本号，但是有没有更好的办法呢？<br>当然，你可以通过Maven的properties（属性）中的revision值来实现：<br>父项目版本parent’s version：<br>![](Pasted image 20230518213525.png)</p>\n<p>父项目中对于子模块依赖管理：统一都使用revision变量：<br>![](Pasted image 20230518213715.png)</p>\n<p>子项目中对于父项目的引用也是revision进行：<br>![](Pasted image 20230518213545.png)</p>\n<p>通过revision变量，你可以通过修改一处的值来升级整个项目的版本号。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>能够更换为其他的变量名呢？可能不行，在IDEA中会有properties are prohibited属性被禁止的错误提示。</p></blockquote>\n<p>![](Pasted image 20230518213428.png)</p>\n","text":"本章节将讲解如何使用单个变量来集中一个由Maven组成的多模块项目的版本号 在开发过程中，我们总是要对项目进行不断的迭代升级，而在Maven的版本控制中，我们可以通过不同的版本号，来将不同版本的项目打包放于同样的地方。![](Pasted image 20230518212916...","link":"","photos":[],"count_time":{"symbolsCount":725,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Maven","slug":"Maven","count":1,"path":"api/tags/Maven.json"}],"toc":"","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"基于Prometheus实现SpringBoot应用数据采集与业务埋点","uid":"51d09946e274f8b72c614484ac075533","slug":"基于Prometheus实现SpringBoot应用数据采集与业务埋点","date":"2023-05-22T14:01:22.000Z","updated":"2023-08-08T09:09:40.307Z","comments":true,"path":"api/articles/基于Prometheus实现SpringBoot应用数据采集与业务埋点.json","cover":null,"text":"前提概要：假设你已经了解了Prometheus是做什么的，以及如何基于Prometheus搭建一个指标监控体系。本章节将讲解如何基于Prometheus对SpringBoot进行指标采集 SpringBoot监控添加prometheus依赖： &lt;!-- for monito...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"},{"name":"Prometheus","slug":"Prometheus","count":1,"path":"api/tags/Prometheus.json"},{"name":"业务","slug":"业务","count":1,"path":"api/tags/业务.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MMAP/Page Cache - 以Javaer的角度看待内存映射文件机制","uid":"90732c789d41e9ff8627e26b080796f4","slug":"java/MMAP与Page Cache","date":"2023-05-09T08:20:21.340Z","updated":"2023-05-09T08:33:56.261Z","comments":true,"path":"api/articles/java/MMAP与Page Cache.json","cover":null,"text":"什么是MMAP？MMAP(Memory-mapped file)是一种内存映射文件的机制。用于建立从文件到内存之间的一种映射，将对磁盘的写入映射为对内存的写入，以增加对于文件IO的效率。 在Linux上主要通过mmap()、munmap()、msync()等系统调用来实现。 什么...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"OS","slug":"OS","count":1,"path":"api/tags/OS.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}