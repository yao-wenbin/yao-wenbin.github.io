{"title":"Kafka搭建、基本配置和调优","uid":"8d37cbd2fbc0c698ac8b858553ced3c3","slug":"Kafka搭建、基本配置和调优","date":"2023-08-09T09:39:17.000Z","updated":"2023-08-09T09:40:46.634Z","comments":true,"path":"api/articles/Kafka搭建、基本配置和调优.json","cover":null,"content":"<p><a href=\"https://kafka.apache.org/quickstart\">Apache Kafka Quick Start</a></p>\n<h1 id=\"Kafka安装\"><a href=\"#Kafka安装\" class=\"headerlink\" title=\"Kafka安装\"></a>Kafka安装</h1><h2 id=\"1-下载资源包\"><a href=\"#1-下载资源包\" class=\"headerlink\" title=\"1. 下载资源包\"></a>1. 下载资源包</h2><p><a href=\"https://kafka.apache.org/downloads\">Apache Kafka Downloads</a> 下载Binary资源包</p>\n<p><a href=\"https://zookeeper.apache.org/releases.html\">Apache ZooKeeper</a> 下载Binary资源包（不带Source Release的那个）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Apache项目发布的时候基本都会有Binary和Source两个版本， Binary是编译好的能够直接使用的，Source是未编译的源代码。 为了更快地时候，我们一般会直接下载Binary二进制包</p></blockquote>\n<h2 id=\"2-启动Zookeeper\"><a href=\"#2-启动Zookeeper\" class=\"headerlink\" title=\"2. 启动Zookeeper\"></a>2. 启动Zookeeper</h2><p><a href=\"https://zookeeper.apache.org/doc/current/zookeeperStarted.html\">ZooKeeper: Because Coordinating Distributed Systems is a Zoo (apache.org)</a><br>添加配置文件：注意这个后缀是cfg</p>\n<pre class=\"line-numbers language-cfg\" data-language=\"cfg\"><code class=\"language-cfg\">vim conf&#x2F;zoo.cfg\n\ntickTime&#x3D;200\ndataDir&#x3D;&#x2F;var&#x2F;lib&#x2F;zookeeper\nclientPort&#x3D;2181<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>启动zookeeper</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">bin/zkServer.sh start<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>如果Macos上运行Zookeeper出现了问题，可以参考一下文章：<br><a href=\"https://www.cnblogs.com/niepeishen/p/15770232.html\">解决Mac上安装Zookeeper问题：FAILED TO WRITE PID - 夜深nps - 博客园 (cnblogs.com)</a></p>\n<h2 id=\"3-启动Kafka\"><a href=\"#3-启动Kafka\" class=\"headerlink\" title=\"3. 启动Kafka\"></a>3. 启动Kafka</h2><p>进入Kafka应用目录</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 后台运行</span>\nbin/kafka-server-start.sh <span class=\"token parameter variable\">-daemon</span> config/server.properties\n<span class=\"token comment\"># 查看日志</span>\n<span class=\"token function\">tail</span> <span class=\"token parameter variable\">-f</span> <span class=\"token variable\">$KAFKA_HOME</span>/logs/zookeeper.out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Kafka服务会默认占用9092端口</p>\n<h2 id=\"4-创建主题测试收发\"><a href=\"#4-创建主题测试收发\" class=\"headerlink\" title=\"4. 创建主题测试收发\"></a>4. 创建主题测试收发</h2><p>使用kafka-topics.sh命令行工具创建主题</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">➜ bin/kafka-topics.sh <span class=\"token parameter variable\">--create</span> <span class=\"token parameter variable\">--topic</span> quickstart-events --bootstrap-server localhost:9092\nCreated topic quickstart-events.\n\n➜ bin/kafka-topics.sh <span class=\"token parameter variable\">--describe</span> <span class=\"token parameter variable\">--topic</span> quickstart-events --bootstrap-server localhost:9092\nTopic: quickstart-events\tTopicId: 9wroEws9SkiToPXeGV9sDg\tPartitionCount: <span class=\"token number\">1</span>\tReplicationFactor: <span class=\"token number\">1</span>\tConfigs:\n\tTopic: quickstart-events\tPartition: <span class=\"token number\">0</span>\tLeader: <span class=\"token number\">0</span>\tReplicas: <span class=\"token number\">0</span>\tIsr: <span class=\"token number\">0</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以看出kafka-topics.sh工具的命令行格式为</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kafka-topics.sh --<span class=\"token operator\">&lt;</span>operatetion<span class=\"token operator\">></span> --<span class=\"token operator\">&lt;</span>topicName<span class=\"token operator\">></span> --boostrap-server <span class=\"token operator\">&lt;</span>kafkaServerHost<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n<p>使用控制台工具测试收发：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n➜ bin&#x2F;kafka-console-producer.sh --topic quickstart-events --bootstrap-server localhost:9092\n&gt;first event\n&gt;second event\n&gt;^C%\n\n\n➜ bin&#x2F;kafka-console-consumer.sh --topic quickstart-events --from-beginning --bootstrap-server localhost:9092\nfirst event\nsecond event<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"安装Kafdrop-运维面板\"><a href=\"#安装Kafdrop-运维面板\" class=\"headerlink\" title=\"安装Kafdrop 运维面板\"></a>安装Kafdrop 运维面板</h2><p>如果你想通过Web UI的方式来对Kafka进行运维以减少使用Kafka运维工具的记忆存储的压力。那么<a href=\"https://github.com/obsidiandynamics/kafdrop\">obsidiandynamics&#x2F;kafdrop: Kafka Web UI (github.com)</a>会是一个不错的选择其支持Jar和Docker的运行方式，只需要简单的配置即可运行。</p>\n<h2 id=\"Docker运行\"><a href=\"#Docker运行\" class=\"headerlink\" title=\"Docker运行\"></a>Docker运行</h2><p>为了更快的部署Kafdrop，我们可以通过Docker快速构建：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker run -d --rm -p 9000:9000 \\\n    -e KAFKA_BROKERCONNECT&#x3D;host.docker.internal:9092 \\\n    -e JVM_OPTS&#x3D;&quot;-Xms32M -Xmx64M&quot; \\\n    -e SERVER_SERVLET_CONTEXTPATH&#x3D;&quot;&#x2F;&quot; \\\n    obsidiandynamics&#x2F;kafdrop<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>你可以通过host.docker.internal地址将主机的IP地址映射至docker容器中</p></blockquote>\n<p>随后Kafdrop会运行在9000端口，我们可以在浏览器中访问，它看起来像这样：<br>![Pasted image 20230809173831.png](Pasted image 20230809173831.png)</p>\n<h1 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h1><h2 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h2><p><code>broekr.id</code> 任何broker都需要指定一个<strong>集群内部唯一的</strong>、<strong>整型的</strong>标识符。 默认配置下这个值为0。</p>\n<p><code>port</code> Kafka服务器占用端口，默认为9092。这个值可以被设置为任意可用的端口，但是如果低于1024，Kafka必须通过root身份进行启动，这并不是一个推荐的配置方式。</p>\n<p><code>zookeeper.connect</code>连接ZK的地址，默认值为2181，可以通过hostname:port&#x2F;path的格式来着指定，如果不指定path则默认为&#x2F;根目录。<br>如果你的ZK集群除了Kafka还被其他应用所使用，那么指定&#x2F;path能够保证数据不会冲突。</p>\n<p><code>log.dirs</code>  Kafka中Broker数据（包括消息、偏移量等）的存储位置，默认为&#x2F;tmp&#x2F;kafka-logs。可以通过<code>,</code>逗号分割多个文件路径，而Broker会将新的分区方在多个路径中最少存储分区的那个路径下，并且能够保证同一个分区的数据总是会放入同一个文件路径。</p>\n<p><code>num.recovery.threads.per.data.dir</code> Kafka中用于打开每一个目录下的分区日志文件的线程数量。</p>\n<ul>\n<li><p>当Kafka正常启动时，用于打开每个线程的日志文件</p>\n</li>\n<li><p>当Kafka启动失败时，用于检查和阶段日志文件</p>\n</li>\n<li><p>当Kafka关闭时，用于关闭日志文件。<br>这个配置仅用于Kafka刚启动和关闭阶段用于文件的打开和关闭，所以理论上将其配置的更大一点以保证多个线程并行操作是合理的。<br>当从异常关闭的Broker中进行回复时，这意味重新启动Broker可能需要较长的时间。<br>线程数量是对于一个文件路径而言的，如果设置了3个文件存储路径，并且将这个线程数来那个设置为8，那么Kafka总共会启动24个线程。</p>\n</li>\n<li><p><code>auto.create.topics.enable</code>当任何客户端访问某一个不存在的主题时，是否允许Broker自动创建主题。<br>  这个配置会可能会引发非预期的行为，所以尽可能的保证这个配置项是关闭的。</p>\n</li>\n</ul>\n<h2 id=\"Topic默认配置项\"><a href=\"#Topic默认配置项\" class=\"headerlink\" title=\"Topic默认配置项\"></a>Topic默认配置项</h2><p>Kafka的服务器（Broker）配置还能够为主题的创建指定许多默认的配置。其中包括一些较为重要的<strong>分区数</strong>和<strong>消息保留</strong>。 服务器应该将其中的配置项设置为基线值，以适应大多数主题。</p>\n<ul>\n<li><code>num.partitions</code>分区数量，默认值为1。主题的分区数量可以通过管理工具进行增加，但是注意，分区数量不能减少。 如果想要手动创建比默认设置更少的分区数，那么可以在通过kafka-topics工具手动指定分区数量。</li>\n</ul>\n<p>分区数量是Kafka集群能够横向扩展的具体已实现，使用更多分区数量能够在集群中新增更多的的Broker时进行负载均衡。</p>\n<p>尽可能的保证Partition分区数量等于或者是倍数于Broker的数量。使得Partition分区能够均衡的负载在每一个Broker上。 这并不是一个必须的选项，你也可以通过创建多个Topic来平衡消息的负载。</p>\n<p>分区数量的设置是Kafka使用者面临的一个关键点，以下是影响分区数量的选择的几个重要因素：</p>\n<ol>\n<li>你期望Topic达到多少的吞吐量？ 100KB&#x2F;s还是1GB&#x2F;s？</li>\n<li>你期望消费单个分区的最大吞吐量是多少？你总是至少一个消费者从分区中读取数据。 如果你的消费者消费速度较慢，比如说需要将数据写入DB，那么DB的写入速度限制这你的消费者速度。（也就是说要考虑到单个分区的吞吐量是否和消费者的消费速度相匹配）。</li>\n<li>同样，你期望生产者的最大吞吐量是多少？通常情况下生产者的生产速度会比消费者要快，</li>\n<li>如果你需要使用Keys来指定消息存放的分区，那么在创建主题的时候就基于未来的使用率，而不是当前的使用率。（这样就能够避免未来需要增加分区数量，进而导致同样Key的新消息和旧消息不再存放于同一个分区上。）</li>\n<li>考虑到磁盘的可用空间和网络的带宽。</li>\n<li>要避免过度高估分区的数量，因为每个分区都会占用Broker上的资源，以及增加Leader的选举时间。</li>\n</ol>\n<ul>\n<li><p><code>log.retention.ms/hours/minutes</code><br>  这是三个参数，都表示着日志的过期时间，默认情况下这个参数为168hours，也就是7天。  如果三个参数都指定了，那么kafka只会保证最小的时间单位的配置项生效，所以推荐使用ms作为配置。</p>\n<p>  过期时间是根据消息的最后修改时间决定的，正常情况下这就是消息被消费的时间。但是当使用管理工具修改了分区数量，可能会导致分区消息的最后修改时间变更，进而产生非预期的行为。</p>\n</li>\n<li><p><code>log.retention.bytes</code><br>  一个<strong>分区</strong>中的日志保留的大小，当分区下的日志文件超过这个大小的时候，超过这个大小的日志文件会被清除。 注意这是一个分区中的大小，意味着一个主题的日志的大小取决于这个值 * 分区数量，并且也会随着分区数量的增加而增加。</p>\n<p>  <strong>log.rentention.bytes和ms 基于时间和大小的两个策略是“或”的逻辑运算。</strong> 也就是当日志文件只要超过了时间点或者是大小，那么其就会被清除。</p>\n</li>\n<li><p>log.segement.bytes<br>  分区中一个日志文件（日志段这个概念可能会有些不好理解）的大小，默认值为1GB。一个日志文件包含着当前分区中的一段连续的日志，当达到文件大小上限之后关闭，创建出一个新的日志文件。</p>\n<p>  减少日志文件的大小，意味着文件会更加频繁的关闭和创建，会减少整个磁盘的写入效率。 但是当主题有着较低的生产效率时，减少日志的文件的大小，却变得十分重要，因为log.retention的两个策略<strong>仅对于关闭的日志文件生效</strong>。</p>\n<p>  假设一个文件的写入效率为100M每天，而log.retention.ms使用了默认值七天，这意味着消息文件在达到第7天的时候，会由于日志还未关闭，进而无法按预期被删除。而仅仅在第十天消息日志文件中的日志达到了上限，进而关闭该文件，随后打开新的日志文件时。这个本应该过期的日志文件才会被删除。</p>\n</li>\n<li><p>log.segement.ms<br>  由时间控制的日志文件的关闭策略，同retention一样，两者策略之间是“或”的逻辑运算。</p>\n<p>  使用log.segement.ms时，如果多个分区的日志文件总是由于时间问题被同时关闭和创建，那么可能会产生磁盘的突刺，从而影响磁盘的性能。</p>\n</li>\n<li><p>message.max.bytes<br>  消息的最大字节数，默认值为1MB，当生产者发送超过了这个大小的消息时，Broker会返回一个错误。<br>  注意这个参数需要和消费者客户端的fetch.message.max.bytes以及Broker端的replica.fetch.max.bytes配置保持一致。否则，会导致消息的拉取无法获得完整的消息数据。</p>\n</li>\n</ul>\n<h1 id=\"硬件选择\"><a href=\"#硬件选择\" class=\"headerlink\" title=\"硬件选择\"></a>硬件选择</h1><p>一个应用绕不开底层硬件的依赖，而影响应用性能的核心无外乎硬盘、内存、网络和CPU四个核心硬件。</p>\n<h2 id=\"磁盘\"><a href=\"#磁盘\" class=\"headerlink\" title=\"磁盘\"></a>磁盘</h2><p>生产者的性能会直接的影响到Broker的磁盘吞吐量，因为只有当Broker将消息写入磁盘时，一个消息才能够被视为真正被生产出来。而生产者客户端会等待直至消息成功写入，才会响应成功。<strong>这意味着更快的磁盘写入能够有更低的生产者写入延迟。</strong></p>\n<p>这就是来到了经典的SSD和HHD的抉择。即使Kafka对于消息的写入是顺序写的，能够很大的利用磁盘的特性。但使用SSD磁盘总是要比HHD的性能更好；如果Kafka对于存储的容量有要求（比如说一天流量为1TB，而消息过期策略为7天，那么至少磁盘要有7TB的空间）。那么采用机械硬盘是更加经济的选择。</p>\n<p>磁盘还和Broker中的Retention过期配置相关，你想要保留的日志时间越长、日志体积越大，那么你就应该需要越多的磁盘空间。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>内存影响着消费者的消费速度，正常情况下生产者的消息追加到Broker之后会立即的被消费者消费，生产者和消费者之间的消息进度差异十分的小。 这种情况下，Broker会将消息存储在系统的PageCache页缓存中，使得消费者的读取速度比Broker从磁盘中重新读取消息更快。 因此提供更多的内存空间用于页缓存将提高客户端的性能。</p>\n<p>需要注意的是操作系统的PageCache页缓存会在多个应用程序之间共享，所以不推荐的将Kafka与其他的重要应用部署在同一台机器上。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><p>每当一个消息从生产者中通过网络入站连接至Broker写入数据， 可能会产生N个消费者的出站连接用于消息的消费。 一个生产者可能产生1MB的数入站据每秒，那么消费者可能消费nMB的出战数据每秒。</p>\n<p>同样为了保证Kafka数据的高可用，其他Kafka应用级别的操作也会占用网络带宽，比如说集群复制。<br>当网络的带宽被生产和消费打满时，集群复制的滞后会变成一个十分常见的问题。</p>\n<ul>\n<li>所以每当发生集群复制滞后时，你就需要检查是否网络带宽一直处于占满的状态。</li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p>CPU在Kafka中仅用于消息的压缩，理想情况下，生产者和消费者今天当消息压缩后从发送至Broker能够减少磁盘和网络的占用。 但是为了校验消息中的checksum校验和以及分配消息的offset偏移量，Kafka需要在接收到来自生产中的压缩消息后，将其解压出来进行操作。校验无误后，然后再压缩存入磁盘。 这是Kafka中对于CPU有所要求的地方。</p>\n<p>但是CPU不应该是Kafka选择硬件的主要因素，优先考虑磁盘和内存。</p>\n<h1 id=\"OS调优\"><a href=\"#OS调优\" class=\"headerlink\" title=\"OS调优\"></a>OS调优</h1><p>Linux的众多发行版中都有能够对内核参数进行配置。 默认配置会对绝大多数的应用都工作的很好，但是依然有一小部分的配置项更改能够使得kafka broker具有更好的性能。</p>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>虚拟内存优化的核心点在于避免内存交换(memory swapping)的成本。kafka是一个重度依赖于虚拟内存和页缓存的应用，如果虚拟内存页交换到磁盘，那么将会显著的影响到Kafka的性能。<br>交换空间能够防止OS由于内存不足而突然禁止进程。</p>\n<p>关于虚拟内存的优秀文章：<br><a href=\"https://www.cnblogs.com/yinzhengjie/p/9994207.html\">Linux虚拟内存（swap）调优篇-“swappiness”,“vm.dirty_background_ratio”和“vm.dirty_ratio” - 尹正杰 - 博客园 (cnblogs.com)</a></p>\n<p>使用虚拟内存会导致数据频繁的从内存写入磁盘，导致性能的下降。而通过配置项<br><code>vm.swappiness = 1</code> 能够使得操作系统尽可能的不使用交换内存，而是使用真实物理内存。<br>查看当前配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> /proc/sys/vm/swappiness<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>临时修改配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sysctl</span> <span class=\"token assign-left variable\">vw.swappiness</span><span class=\"token operator\">=</span><span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>永久修改配置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">echo &quot;vm.swappiness&#x3D;1&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>激活设置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sysctl</span> <span class=\"token parameter variable\">-p</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h2 id=\"脏页Dirty-Page\"><a href=\"#脏页Dirty-Page\" class=\"headerlink\" title=\"脏页Dirty Page\"></a>脏页Dirty Page</h2><p>脏页是Linux内核中的概念，因为磁盘中的读写速度远赶不上内存的速度，所以系统可以将读写频繁的数据先放到内存中，这就叫高速缓存。而Linux中页是高速缓存的单位，当进程应用修改了高速缓存中的页数据时，该内存就会被标记为脏页（因为内存中的数据和磁盘中不一致），直至合适的时候将脏页的数据写入磁盘，以保持高速缓存中的数据和磁盘的一致。</p>\n<p>Linux中提供了两个参数用于调整脏页的处理方式</p>\n<ol>\n<li><code>vm.dirty_background_ratio</code>表示当前脏页所占内存比例达到多少时，Linux会启动后台会写线程，来将脏页异步的写回磁盘。 这个参数的默认值为10，而将其设置为5能够适用于绝大部分应用；</li>\n<li><code>vm.dirty_ratio</code> 表示当脏页占内存比例达到多少时，Linux会阻塞直到脏页被写回磁盘。这个参数的默认值为20，但是我们可以将其设置为更大的值，60~80是一个合理的选择，但是这会带来一些风险，包括未刷新磁盘的数量和同步刷新引起的长时间I&#x2F;O等待。 如果设置了较高的值，建议开启Kafka的复制功能，以防止系统崩溃造成数据丢失。</li>\n</ol>\n<p>设置这两个参数前，你可以先观察当前操作系统的脏页数量，以调优至一个合理的值</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">cat</span> /proc/vmstat <span class=\"token operator\">|</span> <span class=\"token function\">egrep</span> <span class=\"token string\">\"dirty|writeback\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n\n<h2 id=\"磁盘文件系统\"><a href=\"#磁盘文件系统\" class=\"headerlink\" title=\"磁盘文件系统\"></a>磁盘文件系统</h2><p>除了磁盘硬件的选择，Linux上的文件系统也影响着进程的性能。 目前有许多文件系统可供选择，最常见的两个就是EXT4（Fourth Extended File System）和XFS（Extends File System）。 XFS已经变成许多Linux发行版的默认文件系统了，因为其更适用于绝大多数的场景。</p>\n<p>而EXT4在经过一些参数的调整之后能够表现得更好。</p>\n<p>还有一个Linux参数会影响着磁盘的效率，那就是开启<code>noatime</code>选项，在文件系统的元数据中包含了三个时间戳：创建时间（ctime）、修改时间（mtime）和访问时间（atime）。前两者仅在文件被创建和修改的时候所变更，但接触时间不一样，每一次对文件的访问，不论是否修改了数据都会导致atime的变更。而atime的实际作用却并不大，很少有场景会使用它。<br>所以禁用atime是一个明智的选择。</p>\n<h2 id=\"网络Networking\"><a href=\"#网络Networking\" class=\"headerlink\" title=\"网络Networking\"></a>网络Networking</h2><p>调整Linux的默认网络参数是一个使得任何应用程序产生更高网络流量的常见手段。因为默认的Linux参数并不是为了大体量、高速数据传输而设置的。<br>在这一步的设置除了kafka，也是由于大多数的Web应用程序。</p>\n<ul>\n<li><p><code>net.core.wmem_default</code>和<code>net.core.rmem_default</code>控制着套接字发送和接收缓冲区大小，建议设置为131072（128K）是一个较为合理的数值。</p>\n</li>\n<li><p><code>net.core.wmem_max</code>和<code>net.core.rmem_max</code>控制着套接字发送和接收缓冲区的最大大小，设置为2097152（2MB）是一个较为合理的数值。</p>\n</li>\n<li><p>另外要控制TCP套接字的缓存区大小还需要额外通过<code>ipv4.tcp_w/rmem</code>来进行配置，其接受由空格隔开的由三个数值。建议将其设置为<code>4096 65536 2048000</code>其意味着缓冲区的最小、默认和最大大小为4KB、64KB和2MB。 注意这个参数不应该超过<code>net.core.w/rmem_max</code>所设定的值。</p>\n</li>\n<li><p>还有一个十分有用的TCP调优参数<code>net.ipv4.tcp_window_scaling=1</code>。 能够使得客户端数据传输得更加有效率。允许数据在Broker端传输。</p>\n</li>\n</ul>\n<p>另外设置<code>tcp_max_syn_backlog</code>大于默认的1024能够使得LInux接受更大数量的并发连接。<code>net.core.netdev_max_max_backlog</code>大于默认的1000能够应对网络流量的突发，允许更多的流量包在内核排队等待处理。 </p>\n<h2 id=\"G1-JVM垃圾收集器\"><a href=\"#G1-JVM垃圾收集器\" class=\"headerlink\" title=\"G1 JVM垃圾收集器\"></a>G1 JVM垃圾收集器</h2><p>G1垃圾收集器已经在JDK11之后的多个版本中被设置为了默认垃圾收集器，并且在生产环境中得到了稳定的保证。</p>\n<p>在G1垃圾收集器中有两个参数影响着其垃圾收集的性能，分别为</p>\n<ul>\n<li><code>MaxGCPausMills</code>：预期的最大GC停顿时间，G1能够保证尽可能的使得每次垃圾回收都接近这个数值，默认为200。而Kafka对于堆内存的使用十分的高效，所以我们能够将其设置在20，以保证GC停顿不影响到Kafka正常的工作。</li>\n<li><code>InitiatingHeapOccupancyPercent</code>：初始GC时内存占用的百分比，默认值为45，也意味着只有当JVM的堆内存占用达到45%的时候，G1收集器才会开始第一次GC。而我们可以将其设置得更低一点，比如说35。</li>\n</ul>\n<p>但Kafka中默认使用的JDK8中，使用的是CMS + Parnew。而G1垃圾收集器会有有着比CMS更高的内存占用，所以在切换Kafka的垃圾收集器前，先确保Kafka的堆内存至少能够分配4GB的大小，否则或许使用CMS能够以更低的内存开销获得更高的性能。</p>\n<p>要想使得Kafka更换垃圾收集器，我们可以设置环境变量KAFKA_JVM_PERFORMANCE_OPTS</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># export KAFKA_JVM_PERFORMANCE_OPTS&#x3D;&quot;-server -XX:+UseG1GC -XX:MaxGCPauseMills&#x3D;20 -XX:InitiatingHeapOccupancyPercent&#x3D;35 -XX:+DisableExplicitGC -Djava.awt.headless&#x3D;true&quot;\n\n# bin&#x2F;kafka-server-start.sh -daemon config&#x2F;server.properties<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n<h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><p>Kafka使用Zookeeper来存储自身的元数据包括Brokers、Topics和Partitions。 Kafka仅当集群自身发生调整时或者是Consumer Group的关系发生了变化时会对Zookeeper进行写入。 所以Kafka对于Zookeeper的流量占用是较小的。</p>\n<p>所以我们能够使用一个Zookeeper集群来治理多个Kafka集群，并且通过Zookeeper的chroot path来隔离每一个Kafka集群中的数据。</p>\n<p>前面提到了Consumer Group会对Kafka造成写入，Consumer消费者能够配置使用Zookeeper或者是Kafka来提交自身的消费便宜来那个。如果选择了Zookeeper，那么每一个Consumer会对他所消费的分区的偏移量对Zookeeper进行一次写入操作。这会对Zookeeper产生相当大的流量。 所以推荐的做法是使用Kafka Broker本身来提交偏移量从而消除对Zookeeper的依赖。</p>\n<p>另外不建议将使用一个Zookeeper集群来同时管理Kafka集群和其他应用。因为当其他应用对Zookeeper产生了较大的流量时，可能会影响Kafka集群自身的治理，进而导致Kafka集群的所有Broker节点由于丢失了Zookeeper的连接导致同时下线。</p>\n","text":"Apache Kafka Quick Start Kafka安装1. 下载资源包Apache Kafka Downloads 下载Binary资源包 Apache ZooKeeper 下载Binary资源包（不带Source Release的那个） Apache项目发布的时候基本...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":5,"path":"api/tags/MQ.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Kafka%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">Kafka安装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%8B%E8%BD%BD%E8%B5%84%E6%BA%90%E5%8C%85\"><span class=\"toc-text\">1. 下载资源包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%90%AF%E5%8A%A8Zookeeper\"><span class=\"toc-text\">2. 启动Zookeeper</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%90%AF%E5%8A%A8Kafka\"><span class=\"toc-text\">3. 启动Kafka</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E6%B5%8B%E8%AF%95%E6%94%B6%E5%8F%91\"><span class=\"toc-text\">4. 创建主题测试收发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85Kafdrop-%E8%BF%90%E7%BB%B4%E9%9D%A2%E6%9D%BF\"><span class=\"toc-text\">安装Kafdrop 运维面板</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Docker%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">Docker运行</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">基本配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Broker\"><span class=\"toc-text\">Broker</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Topic%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E9%A1%B9\"><span class=\"toc-text\">Topic默认配置项</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A1%AC%E4%BB%B6%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">硬件选择</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98\"><span class=\"toc-text\">磁盘</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98\"><span class=\"toc-text\">内存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">网络</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CPU\"><span class=\"toc-text\">CPU</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#OS%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">OS调优</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\"><span class=\"toc-text\">虚拟内存</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%84%8F%E9%A1%B5Dirty-Page\"><span class=\"toc-text\">脏页Dirty Page</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">磁盘文件系统</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9CNetworking\"><span class=\"toc-text\">网络Networking</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#G1-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">G1 JVM垃圾收集器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Zookeeper\"><span class=\"toc-text\">Zookeeper</span></a></li></ol></li></ol>","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"kafka-请求处理","uid":"d709ff68faafebbf1f49a2d66baac1a6","slug":"kafka-请求处理","date":"2023-08-14T13:59:14.000Z","updated":"2023-08-14T14:02:59.448Z","comments":true,"path":"api/articles/kafka-请求处理.json","cover":null,"text":"kafka中broker与client的交互都是通过TCP协议来实现的，通过固定的请求格式和请求响应。 任何请求都能够按照顺序被响应，使得 kafka 能够向队列一样保证消息的存储数据。 请求头由什么构成？每个请求头都包含四个固定的参数： Request type，请求类型，也叫...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":5,"path":"api/tags/MQ.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Kafka架构与核心概念","uid":"b616fd44c5f7ef9bc2632badbc783987","slug":"Kafka架构与核心概念","date":"2023-08-08T08:57:39.000Z","updated":"2023-08-08T09:15:12.609Z","comments":true,"path":"api/articles/Kafka架构与核心概念.json","cover":null,"text":"![](Pasted image 20230808161829.png) Kafka Cluster集群：Kafka集群会由一个或多个Broker（有的地方也叫server或者是node）组成，Broker负责Producer和Consumer之间的消息传递和持久化。 是整个架构...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":5,"path":"api/tags/MQ.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}