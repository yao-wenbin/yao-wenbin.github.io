{"title":"kafka-请求处理","uid":"d709ff68faafebbf1f49a2d66baac1a6","slug":"kafka-请求处理","date":"2023-08-14T13:59:14.000Z","updated":"2023-08-14T14:02:59.448Z","comments":true,"path":"api/articles/kafka-请求处理.json","cover":null,"content":"<p>kafka中broker与client的交互都是通过TCP协议来实现的，通过固定的请求格式和请求响应。</p>\n<p>任何请求都能够按照顺序被响应，使得 kafka 能够向队列一样保证消息的存储数据。</p>\n<h2 id=\"请求头由什么构成？\"><a href=\"#请求头由什么构成？\" class=\"headerlink\" title=\"请求头由什么构成？\"></a>请求头由什么构成？</h2><p>每个请求头都包含四个固定的参数：</p>\n<ul>\n<li>Request type，请求类型，也叫做API</li>\n<li>Request version，请求版本，使得broker能够针对不同的请求版本产生不同的行为。</li>\n<li>Correlation ID，关联ID，一个唯一的请求标识符，同时在响应或者是错误日志也会带上关联ID，使得kafka能够根据关联ID快速找到一个请求，进行问题排查。</li>\n<li>Client ID，客户端ID，客户端的标识符。</li>\n</ul>\n<h2 id=\"请求交互\"><a href=\"#请求交互\" class=\"headerlink\" title=\"请求交互\"></a>请求交互</h2><p>kafka的请求处理是基于主从Reactor模式的。 每一个Broker的。都会有一个统一的Acceptor线程用于建立请求链接，随后将其传递给request类型所对应的processor处理。 processor对应的线程也被称之为network thread 网络I&#x2F;O线程。 默认数量为3是可配置的（num.network.threads）。</p>\n<p>网络线程并不参与实际请求的处理，而只是将其放入request queue中，随后从response queue中将响应取出返回给客户端。交互模型看起来像这样：<br>![Pasted image 20230814214234.png](Pasted image 20230814214234.png)</p>\n<p>TODO：kafka源代码中的处理模型是什么样的？ 是否是像RocketMQ那样，每一个Request都有当度配置的线程池？</p>\n<h2 id=\"请求类型\"><a href=\"#请求类型\" class=\"headerlink\" title=\"请求类型\"></a>请求类型</h2><p>绝大多数请求都有来自Producer的Produce Request和来自Consumer的Fetch Request组成。 另外还有一类型的请求用于获取kafka集群当前元数据的被称之为Meta Request。</p>\n<p>每当一个client连接上kafka集群后，会向集群中的任意节点发送一个meta request，以获取client感兴趣的topic主题列表，以及topic下的分区Leader存在于哪一个节点。</p>\n<h2 id=\"当kafka发送给错误的Leader会发生什么？\"><a href=\"#当kafka发送给错误的Leader会发生什么？\" class=\"headerlink\" title=\"当kafka发送给错误的Leader会发生什么？\"></a>当kafka发送给错误的Leader会发生什么？</h2><p>当出现分区副本的Leader节点易主时，client（不管是producer还是consumer）向原leader发送的请求会被响应一个”Not a Leader for Partition”的请求。 当client收到该响应时，会立即的发送一个MetaRequest来更新kafka集群中的Metadata元数据。</p>\n<h2 id=\"Produce-Request-生产请求\"><a href=\"#Produce-Request-生产请求\" class=\"headerlink\" title=\"Produce Request 生产请求\"></a>Produce Request 生产请求</h2><p>当一个生产者将消息发送到所在分区Leader的Broker节点后，Broker会执行一些校验：</p>\n<ol>\n<li>Producer是否有对该主题的写入权限？</li>\n<li>Producer中配置的<code>ack</code>参数是否有效？</li>\n<li>当<code>ack</code>参数为all时，当前分区的ISR副本中是否能够满足安全的写入？</li>\n</ol>\n<p>随后消息会被写入到本地磁盘中，在Linux系统上，会通过mmap机制写入一个名为Page Cache的内存映射区域中。 随后如果<code>ack</code>的参数为0或者1，那么该请求将会直接响应给Producer， 而如果为-1（all）那么响应将进入一个名为purgatory的Buffer缓冲中，直至ISR同步完成之后再返回。</p>\n","text":"kafka中broker与client的交互都是通过TCP协议来实现的，通过固定的请求格式和请求响应。 任何请求都能够按照顺序被响应，使得 kafka 能够向队列一样保证消息的存储数据。 请求头由什么构成？每个请求头都包含四个固定的参数： Request type，请求类型，也叫...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":5,"path":"api/tags/MQ.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%94%B1%E4%BB%80%E4%B9%88%E6%9E%84%E6%88%90%EF%BC%9F\"><span class=\"toc-text\">请求头由什么构成？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E4%BA%A4%E4%BA%92\"><span class=\"toc-text\">请求交互</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">请求类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BD%93kafka%E5%8F%91%E9%80%81%E7%BB%99%E9%94%99%E8%AF%AF%E7%9A%84Leader%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">当kafka发送给错误的Leader会发生什么？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Produce-Request-%E7%94%9F%E4%BA%A7%E8%AF%B7%E6%B1%82\"><span class=\"toc-text\">Produce Request 生产请求</span></a></li></ol>","author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"kafka-存储原理","uid":"dd39451fcd6a79af30692832dae32cef","slug":"kafka-存储原理","date":"2023-08-14T14:00:17.000Z","updated":"2023-08-14T14:02:34.072Z","comments":true,"path":"api/articles/kafka-存储原理.json","cover":null,"text":"本章节将讲解Kafka的底层存储机制，如何实现分区副本的分配、索引机制、如何管理文件以及重要的Kafka压缩机制。 持久化文件系统Kafka重度的依赖于文件系统来存储和缓存消息，即使磁盘通常被认为性能十分缓慢。但实际上，磁盘的读写性能取决于其使用的场景。一个设计良好的磁盘结构能够...","link":"","photos":[],"count_time":{"symbolsCount":"8.2k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":5,"path":"api/tags/MQ.json"},{"name":"Raft","slug":"Raft","count":1,"path":"api/tags/Raft.json"},{"name":"Rate Limiting","slug":"Rate-Limiting","count":1,"path":"api/tags/Rate-Limiting.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Kafka搭建、基本配置和调优","uid":"8d37cbd2fbc0c698ac8b858553ced3c3","slug":"Kafka搭建、基本配置和调优","date":"2023-08-09T09:39:17.000Z","updated":"2023-08-09T09:40:46.634Z","comments":true,"path":"api/articles/Kafka搭建、基本配置和调优.json","cover":null,"text":"Apache Kafka Quick Start Kafka安装1. 下载资源包Apache Kafka Downloads 下载Binary资源包 Apache ZooKeeper 下载Binary资源包（不带Source Release的那个） Apache项目发布的时候基本...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"MQ","slug":"MQ","count":5,"path":"api/tags/MQ.json"}],"author":{"name":"姚文彬","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"深入底层 掌握脉搏","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}