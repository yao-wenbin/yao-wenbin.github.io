{"title":"OkHttp：更加优雅的客户端OkHttps","uid":"c7562fc289c09e37ab4a4b417948e80b","slug":"OkHttp：更加优雅的客户端OkHttps","date":"2022-11-21T00:55:52.000Z","updated":"2022-11-21T00:56:34.620Z","comments":true,"path":"api/articles/OkHttp：更加优雅的客户端OkHttps.json","cover":null,"content":"<p>上文中，我们介绍了OkHttp的一些常见的用法，以及对其API进行了一些便于调用的封装。而笔者在深入学习的过程中发现了一个基于Lambda表达式、链式调用进行封装的OkHttps，使其的调用方式更加的优雅、简介。</p>\n<p>简介<br><a href=\"https://ok.zhxu.cn/v4/introduction.html\">https://ok.zhxu.cn/v4/introduction.html</a><br>OkHttps 是 2020 年开源的对 OkHttp3 轻量封装的框架，它独创的异步预处理器，特色的标签，灵活的上传下载进度监听与过程控制功能，在轻松解决很多原本另人头疼问题的同时，设计上也力求纯粹与优雅。</p>\n<p>Maven中要想使用OkHttps，我们需要引入一个OkHttps核心包和一个OkHttps-xxxx(序列化框架)的序列化包，比如FastJson2，我们可以通过<br><dependency><br>     <groupId>cn.zhxu</groupId><br>     <artifactId>okhttps</artifactId><br>     <version>4.0.0</version><br></dependency><br><dependency><br>     <groupId>cn.zhxu</groupId><br>     <artifactId>okhttps-fastjson2</artifactId><br>     <version>4.0.0</version><br></dependency></p>\n<p>如果是Jackson的话，我们只需要将fastjson2换成<br><dependency><br>     <groupId>cn.zhxu</groupId><br>     <artifactId>okhttps-jackson</artifactId><br>     <version>4.0.0</version><br></dependency><br>即可。</p>\n<p>基本使用</p>\n<p>首先，我们需要向使用OkHttp那样，构建一个HTTP请求， 为了使用方便，我们更愿意指定一个BaseUrl和MsgConverter：<br>HTTP http &#x3D; HTTP.builder()<br>        .baseUrl(“<a href=\"http://api.example.com&quot;/\">http://api.example.com&quot;</a>)<br>        &#x2F;&#x2F; GsonMsgConverter源自okhttps-gons包中，使用时更换为实际导入的序列化包<br>        .addMsgConvertor(new GsonMsgConvertor())<br>        .build();</p>\n<p>随后，我们可以通过链式调用的方式来开始一个同步请求了：<br>List<User> users &#x3D; http.sync(“&#x2F;users”) &#x2F;&#x2F; <a href=\"http://api.example.com/users\">http://api.example.com/users</a><br>        .get()                         &#x2F;&#x2F; GET请求<br>        .getBody()                     &#x2F;&#x2F; 获取响应报文体<br>        .toList(User.class);           &#x2F;&#x2F; 得到目标数据<br>或者是一个异步请求：<br>http.async(“&#x2F;users&#x2F;1”)                &#x2F;&#x2F;  <a href=\"http://api.example.com/users/1\">http://api.example.com/users/1</a><br>        .setOnResponse((HttpResult res) -&gt; {<br>            &#x2F;&#x2F; 得到目标数据<br>            User user &#x3D; res.getBody().toBean(User.class);<br>        })<br>        .get();                       &#x2F;&#x2F; GET请求<br>如果你想要一个WebSocket通讯的话，可以这样：<br>http.webSocket(“&#x2F;chat”)<br>        .setOnOpen((WebSocket ws, HttpResult res) -&gt; {<br>            ws.send(“向服务器问好”);<br>        })<br>        .setOnMessage((WebSocket ws，Message msg) -&gt; {<br>            &#x2F;&#x2F; 从服务器接收消息（自动反序列化）<br>            Chat chat &#x3D; msg.toBean(Chat.class);<br>            &#x2F;&#x2F; 相同的消息发送给服务器（自动序列化 Chat 对象）<br>            ws.send(chat);<br>        })<br>        .listen();                     &#x2F;&#x2F; 启动监听</p>\n<p>请求三部曲<br>对于任何请求，OkHttps都可以将其看作为三个步骤：</p>\n<ol>\n<li>确定请求方式（同步、异步） </li>\n<li>构建请求任务（添加请求参数、设置回调函数） </li>\n<li>调用请求方法（get、post、delete、put）<br>而对于这种模板化的开发方式，作为IDEA的开发者我们可以通过Live Template来提高我们的开发效率：</li>\n</ol>\n<p>注入配置<br>OkHttps还支持通过SPI的方式注入自定义配置类</p>\n<p>第一步：新建一个配置类实现cn.zhxu.okhttps.Config接口<br>package com.example.okhttps;</p>\n<p>import cn.zhxu.okhttps.Config;<br>import cn.zhxu.okhttps.HTTP;</p>\n<p>public class OkHttpsConfig implements Config {</p>\n<pre><code>@Override\npublic void with(HTTP.Builder builder) &#123;\n    // 在这里对 HTTP.Builder 做一些自定义的配置\n    builder.baseUrl(&quot;https://api.domo.com&quot;);\n    // 如果项目中添加了 okhttps-fastjson 或 okhttps-gson 或 okhttps-jackson 依赖\n    // OkHttps 会自动注入它们提供的 MsgConvertor \n    // 所以这里就不需要再配置 MsgConvertor 了 (内部实现自动注入的原理也是 SPI)\n    // 但如果没有添加这些依赖，那还需要自定义一个 MsgConvertor\n    builder.addMsgConvertor(new MyMsgConvertor());\n&#125;\n</code></pre>\n<p>}<br>第二步：在项目的&#x2F;src&#x2F;main&#x2F;目录下新建resources&#x2F;META-INF&#x2F;services&#x2F;cn.zhxu.okhttps.Config文件，文件内容是上一个配置类的全类名</p>\n<p>为什么要使用SPI注入配置而不是直接给OkHttps设置一个静态变量实例呢？<br>在一般情况下这样是没问题的，但是某些JVM上（特别是Android）会在某些情况下回收静态变量，而OkHttps的HTTP实例一旦被回收之后，配置都会丢失，导致严重的问题。</p>\n<p>对于SpringBoot项目，如果还想要导入application.yml的配置的话，我们可以现在Spring的Bean中加载配置，然后提供静态访问方法，再去配置类中访问这个Bean。<br>@Component<br>public class ConfigBean {</p>\n<pre><code>@Value(&quot;$&#123;okhttps.baseUrl&#125;&quot;)    // 加载配置\nprivate String baseUrl;\n\nprivate static ConfigBean instance;\n\npublic ConfigBean() &#123;\n    instance = this;            // 将该 Bean 单例化\n&#125;\n\npublic static ConfigBean getInstance() &#123;\n    return instance;            // 提供静态访问方法\n&#125;\n\n// 省略 Getter Seatter\n</code></pre>\n<p>}<br>public class OkHttpsConfig implements Config {</p>\n<pre><code>@Override\npublic void with(HTTP.Builder builder) &#123;\n    // 获取 ConfigBean\n    ConfigBean confg = ConfigBean.getInstance();\n    // 使用配置\n    builder.baseUrl(confg.getBaseUrl());\n    // 省略其它配置\n&#125;\n</code></pre>\n<p>}</p>\n","text":"上文中，我们介绍了OkHttp的一些常见的用法，以及对其API进行了一些便于调用的封装。而笔者在深入学习的过程中发现了一个基于Lambda表达式、链式调用进行封装的OkHttps，使其的调用方式更加的优雅、简介。 简介https://ok.zhxu.cn/v4/introduct...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"工具","slug":"工具","count":2,"path":"api/tags/工具.json"},{"name":"OkHttp","slug":"OkHttp","count":2,"path":"api/tags/OkHttp.json"}],"toc":"","author":{"name":"yaowenbin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位不断成长的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"你真的了解你的MySQL吗(MySQL基准测试)","uid":"4468f948c4ca4e742d657728958a113e","slug":"你真的了解你的MySQL吗-MySQL基准测试","date":"2022-11-12T13:31:33.000Z","updated":"2022-11-12T13:31:47.878Z","comments":true,"path":"api/articles/你真的了解你的MySQL吗-MySQL基准测试.json","cover":[],"text":"如果你没有真正的对服务器上的MySQL进行基准测试，就无法了解其真实情况到底是如何。 基准测试是数据库工程师必备的技能之一，否则你如何知道自己真的在优化数据库？ 为什么需要基测？基测可以观察系统在不同压力下的行为： 验证基于系统的一些假设是否符合实际情况。 测试当前的运行情况，如...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":5,"path":"api/tags/MySQL.json"}],"author":{"name":"yaowenbin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位不断成长的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"减少你的代码量：基于AOP实现字典翻译","uid":"db73c7a78b5189912e109ef7e8566686","slug":"减少你的代码量：基于AOP实现字典翻译","date":"2022-11-18T09:40:43.000Z","updated":"2022-11-18T09:42:35.819Z","comments":true,"path":"api/articles/减少你的代码量：基于AOP实现字典翻译.json","cover":[],"text":"什么是字典？开发者更加倾向于使用短小的字段类型比如 tinyint、char(1)等来存储一些类型字段，以让每个数据都能够尽可能少的占用空间。 而用户当然不买单，希望能够看到每个字段都真正含义（比如 status &#x3D; 1时，其真正含义是状态进行中， status &#x...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"SpringAOP","slug":"SpringAOP","count":1,"path":"api/tags/SpringAOP.json"},{"name":"减少你的代码量","slug":"减少你的代码量","count":1,"path":"api/tags/减少你的代码量.json"}],"author":{"name":"yaowenbin","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位不断成长的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}